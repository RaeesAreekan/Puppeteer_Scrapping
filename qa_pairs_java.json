[
  {
    "question": "1. Is Java Platform Independent if then how?",
    "answer": "Yes, Java is a Platform Independent language. Unlike many programming languages javac compiler compiles the program to form a bytecode or .class file. This file is independent of the software or hardware running but needs a JVM(Java Virtual Machine) file preinstalled in the operating system for further execution of the bytecode.\nAlthough JVM is platform dependent, the bytecode can be created on any System and can be executed in any other system despite hardware or software being used which makes Java platform independent."
  },
  {
    "question": "2. What are the top Java Features?",
    "answer": "Java is one the most famous and most used language in the real world, there are many features in Java that makes it better than any other language some of them are mentioned below:\n\nSimple: Java is quite simple to understand and the syntax\nPlatform Independent: Java is platform independent means we can run the same program in any software and hardware and will get the same result.\nInterpreted: Java is interpreted as well as a compiler-based language. \nRobust: features like Garbage collection, exception handling, etc that make the language robust.\nObject-Oriented: Java is an object-oriented language that supports the concepts of class,  objects, four pillars of OOPS, etc. \nSecured: As we can directly share an application with the user without sharing the actual program makes Java a secure language. \nHigh Performance:  faster than other traditional interpreted programming languages.\nDynamic: supports dynamic loading of classes and interfaces.\nDistributed: feature of Java makes us able to access files by calling the methods from any machine connected.\nMultithreaded: deal with multiple tasks at once by defining multiple threads\nArchitecture Neutral: it is not dependent on the architecture."
  },
  {
    "question": "3. What is JVM?",
    "answer": "JVM stands for Java Virtual Machine it is a Java interpreter. It is responsible for loading, verifying, and executing the bytecode created in Java.\nAlthough it is platform dependent which means the software of JVM is different for different Operating Systems it plays a vital role in making Java platform Independent.\nTo know more about the topic refer to JVM in Java."
  },
  {
    "question": "4. What is JIT?",
    "answer": "JIT stands for (Just-in-Time) compiler is a part of JRE(Java Runtime Environment), it is used for better performance of the Java applications during run-time. The use of JIT is mentioned in step by step process mentioned below:\nSource code is compiled with javac compiler to form bytecode\nBytecode is further passed on to JVM \nJIT is a part of JVM, JIT is responsible for compiling bytecode into native machine code at run time.\nThe JIT compiler is enabled throughout, while it gets activated when a method is invoked. For a compiled method, the JVM directly calls the compiled code, instead of interpreting it.\nAs JVM calls the compiled code that increases the performance and speed of the execution.\nTo know more about the topic refer to JIT in Java."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "5. What are Memory storages available with JVM?",
    "answer": "JVM consists of a few memory storages as mentioned below:\nClass(Method) Area: stores class-level data of every class such as the runtime constant pool, field, and method data, and the code for methods.\nHeap: Objects are created or objects are stored. It is used to allocate memory to objects during run time.\nStack: stores data and partial results which will be needed while returning value for method and performing dynamic linking\nProgram Counter Register: stores the address of the Java virtual machine instruction currently being executed.\nNative Method Stack: stores all the native methods used in the application.\nTo know more about the topic refer to JVM Memory Storages."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "6. What is a classloader?",
    "answer": "Classloader is the part of JRE(Java Runtime Environment), during the execution of the bytecode or created .class file classloader is responsible for dynamically loading the java classes and interfaces to JVM(Java Virtual Machine). Because of classloaders Java run time system does not need to know about files and file systems.\nTo know more about the topic refer to ClassLoader in Java."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "7. Difference between JVM, JRE, and JDK.",
    "answer": "JVM: JVM also known as Java Virtual Machine is a part of JRE. JVM is a type of interpreter responsible for converting bytecode into machine-readable code. JVM itself is platform dependent but it interprets the bytecode which is the platform-independent reason why Java is platform-independent. \nJRE: JRE stands for Java Runtime Environment, it is an installation package that provides an environment to run the Java program or application on any machine.\nJDK: JDK stands for Java Development Kit which provides the environment to develop and execute Java programs. JDK is a package that includes two things Development Tools to provide an environment to develop your Java programs and, JRE to execute Java programs or applications.\nTo know more about the topic refer to the Differences between JVM, JRE, and JDK."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "8. What are the differences between Java and C++?",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "9. Explain public static void main(String args[]) in Java.",
    "answer": "Unlike any other programming language like C, C++, etc. In Java, we declared the main function as a public static void main (String args[]). The meanings of the terms are mentioned below:\npublic: the public is the access modifier responsible for mentioning who can access the element or the method and what is the limit.  It is responsible for making the main function globally available. It is made public so that JVM can invoke it from outside the class as it is not present in the current class.\nstatic: static is a keyword used so that we can use the element without initiating the class so to avoid the unnecessary allocation of the memory. \nvoid: void is a keyword and is used to specify that a method doesn’t return anything. As the main function doesn’t return anything we use void.\nmain: main represents that the function declared is the main function. It helps JVM to identify that the declared function is the main function.\nString args[]: It stores Java command-line arguments and is an array of type java.lang.String class."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "10. What is Java String Pool?",
    "answer": "A Java String Pool is a place in heap memory where all the strings defined in the program are stored. A separate place in a stack is there where the variable storing the string is stored. Whenever we create a new string object, JVM checks for the presence of the object in the String pool, If String is available in the pool, the same object reference is shared with the variable, else a new object is created.\n\nExample:\nString str1=\"Hello\";\n// \"Hello\" will be stored in String Pool\n// str1 will be stored in stack memory"
  },
  {
    "question": "11. What will happen if we declare don’t declare the main as static?",
    "answer": "We can declare the main method without using static and without getting any errors. But, the main method will not be treated as the entry point to the application or the program."
  },
  {
    "question": "12. What are Packages in Java?",
    "answer": "Packages in Java can be defined as the grouping of related types of classes, interfaces, etc providing access to protection and namespace management."
  },
  {
    "question": "13. Why Packages are used?",
    "answer": "Packages are used in Java in order to prevent naming conflicts, control access, and make searching/locating and usage of classes, interfaces, etc easier."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "14. What are the advantages of Packages in Java?",
    "answer": "There are various advantages of defining packages in Java.\nPackages avoid name clashes.\nThe Package provides easier access control.\nWe can also have the hidden classes that are not visible outside and are used by the package.\nIt is easier to locate the related classes."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "15. How many types of packages are there in Java?",
    "answer": "There are two types of packages in Java\nUser-defined packages\nBuild In packages"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "16. Explain different data types in Java.",
    "answer": "There are 2 types of data types in Java as mentioned below:\nPrimitive Data Type\nNon-Primitive Data Type or Object Data type\nPrimitive Data Type: Primitive data are single values with no special capabilities. There are 8 primitive data types:\nboolean: stores value true or false\nbyte: stores an 8-bit signed two’s complement integer\nchar: stores a single 16-bit Unicode character\nshort: stores a 16-bit signed two’s complement integer\nint: stores a 32-bit signed two’s complement integer\nlong: stores a 64-bit two’s complement integer\nfloat: stores a single-precision 32-bit IEEE 754 floating-point\ndouble: stores a double-precision 64-bit IEEE 754 floating-point\nNon-Primitive Data Type: Reference Data types will contain a memory address of the variable’s values because it is not able to directly store the values in the memory. Types of Non-Primitive are mentioned below:\nStrings\nArray\nClass\nObject\nInterface"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "17. When a byte datatype is used?",
    "answer": "A byte is an 8-bit signed two-complement integer. The minimum value supported by bytes is -128 and 127 is the maximum value. It is used in conditions where we need to save memory and the limit of numbers needed is between -128 to 127."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "18. Can we declare Pointer in Java?",
    "answer": "No, Java doesn’t provide the support of Pointer. As Java needed to be more secure because which feature of the pointer is not provided in Java."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "19. What is the default value of byte datatype in Java?",
    "answer": "The default value of the byte datatype in Java is 0."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "20. What is the default value of float and double datatype in Java?",
    "answer": "The default value of the float is 0.0f and of double is 0.0d in Java."
  },
  {
    "question": "21. What is the Wrapper class in Java?",
    "answer": "Wrapper, in general, is referred to a larger entity that encapsulates a smaller entity. Here in Java, the wrapper class is an object class that encapsulates the primitive data types. \nThe primitive data types are the ones from which further data types could be created. For example, integers can further lead to the construction of long, byte, short, etc. On the other hand, the string cannot, hence it is not primitive. \nGetting back to the wrapper class, Java contains 8 wrapper classes. They are Boolean, Byte, Short, Integer, Character, Long, Float, and Double. Further, custom wrapper classes can also be created in Java which is similar to the concept of Structure in the C programming language. We create our own wrapper class with the required data types."
  },
  {
    "question": "22. Why do we need wrapper classes?",
    "answer": "The wrapper class is an object class that encapsulates the primitive data types, and we need them for the following reasons:\nWrapper classes are final and immutable\nProvides methods like valueOf(), parseInt(), etc.\nIt provides the feature of autoboxing and unboxing."
  },
  {
    "question": "23. Differentiate between instance and local variables.",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "24. What are the default values assigned to variables and instances in Java?",
    "answer": "In Java When we haven’t initialized the instance variables then the compiler initializes them with default values. The default values for instances and variables depend on their data types. Some common types of default data types are:\nThe default value for numeric types (byte, short, int, long, float, and double) is 0.\nThe default value for the boolean type is false.\nThe default value for object types (classes, interfaces, and arrays) is null.\nThe null character, “u0000, ” is the default value for the char type.\nExample:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "25. What is a Class Variable?",
    "answer": "In Java, a class variable (also known as a static variable) is a variable that is declared within a class but outside of any method, constructor, or block. Class variables are declared with the static keyword, and they are shared by all instances (objects) of the class as well as by the class itself. No matter how many objects are derived from a class, each class variable would only exist once.\nExample:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "26. What is the default value stored in Local Variables?",
    "answer": "There is no default value stored with local variables. Also, primitive variables and objects don’t have any default values."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "27. Explain the difference between instance variable and a class variable.",
    "answer": "Instance Variable: A class variable without a static modifier known as an instance variable is typically shared by all instances of the class. These variables can have distinct values among several objects. The contents of an instance variable are completely independent of one object instance from another because they are related to a specific object instance of the class.\nExample:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "28. What is a static variable?",
    "answer": "The static keyword is used to share the same variable or method of a given class. Static variables are the variables that once declared then a single copy of the variable is created and shared among all objects at the class level."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "29. What is the difference between System.out, System.err, and System.in?",
    "answer": "System.out – It is a PrintStream that is used for writing characters or can be said it can output the data we want to write on the Command Line Interface console/terminal. \nExample:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "30. What do you understand by an IO stream?",
    "answer": "Java brings various Streams with its I/O package that helps the user to perform all the input-output operations. These streams support all types of objects, data types, characters, files, etc to fully execute the I/O operations."
  },
  {
    "question": "31. What is the difference between the Reader/Writer class hierarchy and the InputStream/OutputStream class hierarchy?",
    "answer": "The key difference between them is that byte stream data is read and written by input/output stream classes. Characters are handled by the Reader and Writer classes. In contrast to Reader/Writer classes, which accept character arrays as parameters, input/output stream class methods accept byte arrays. In comparison to input/output streams, the Reader/Writer classes are more efficient, handle all Unicode characters, and are useful for internalization. Use Reader/Writer classes instead of binary data, such as pictures, unless you do so.\nExample:"
  },
  {
    "question": "32. What are the super most classes for all the streams?",
    "answer": "All the stream classes can be divided into two types of classes that are ByteStream classes and CharacterStream Classes. The ByteStream classes are further divided into InputStream classes and OutputStream classes. CharacterStream classes are also divided into Reader classes and Writer classes. The SuperMost classes for all the InputStream classes is java.io.InputStream and for all the output stream classes is java.io.OutPutStream. Similarly, for all the reader classes, the super-most class is java.io.Reader, and for all the writer classes, it is java.io.Writer."
  },
  {
    "question": "33. What are the FileInputStream and FileOutputStream?",
    "answer": "To read and write data, Java offers I/O Streams. A Stream represents an input source or an output destination, which could be a file, an i/o device, another program, etc. FileInputStream in Java is used to read data from a file as a stream of bytes. It is mostly used for reading binary data such as images, audio files, or serialized objects. \nExample:\nFile file = new File(\"path_of_the_file\");\nFileInputStream inputStream = new FileInputStream(file);\n\n\n\nIn Java, the FileOutputStream function is used to write data byte by byte into a given file or file descriptor. Usually, raw byte data, such as pictures, is written into a file using FileOutputStream.\nExample:\nFile file = new File(\"path_of_the_file\");\nFileOutputStream outputStream = new FileOutputStream(file);"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "34. What is the purpose of using BufferedInputStream and BufferedOutputStream classes?",
    "answer": "When we are working with the files or stream then to increase the Input/Output performance of the program we need to use the BufferedInputStream and BufferedOutputStream classes. These both classes provide the capability of buffering which means that the data will be stored in a buffer before writing to a file or reading it from a stream. It also reduces the number of times our OS needs to interact with the network or the disk. Buffering allows programs to write a big amount of data instead of writing it in small chunks. This also reduces the overhead of accessing the network or the disk. \nBufferedInputStream(InputStream inp);\n// used to create the bufferinput stream and save the arguments.\n\n\n\nBufferedOutputStream(OutputStream output);\n// used to create a new buffer with the default size."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "35. What are FilterStreams?",
    "answer": "Stream filter or Filter Streams returns a stream consisting of the elements of this stream that match the given predicate. While working filter() it doesn’t actually perform filtering but instead creates a new stream that, when traversed, contains the elements of initial streams that match the given predicate.\nExample:\nFileInputStream fis =new FileInoutStream(\"file_path\"); \nFilterInputStream = new BufferedInputStream(fis);"
  },
  {
    "question": "36. What is an I/O filter?",
    "answer": "An I/O filter also defined as an Input Output filter is an object that reads from one stream and writes data to input and output sources. It used java.io package to use this filter."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "37. How many ways you can take input from the console?",
    "answer": "There are two methods to take input from the console in Java mentioned below:\nUsing Command line argument\nUsing Buffered Reader Class\nUsing Console Class\nUsing Scanner Class\nThe program demonstrating the use of each method is given below.\nExample:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "38. Difference in the use of print, println, and printf.",
    "answer": "print, println, and printf all are used for printing the elements but print prints all the elements and the cursor remains in the same line. println shifts the cursor to next line. And with printf we can use format identifiers too."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "39. What are operators? ",
    "answer": "Operators are the special types of symbols used for performing some operations over variables and values."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "40. How many types of operators are available in Java? ",
    "answer": "All types of operators in Java are mentioned below:\nArithmetic Operators\nUnary Operators\nAssignment Operator\nRelational Operators\nLogical Operators\nTernary Operator\nBitwise Operators\nShift Operators\ninstance of operator\nPostfix operators are considered as the highest precedence according to Java operator precedence."
  },
  {
    "question": "41. Explain the difference between >> and >>> operators.",
    "answer": "Operators like >> and >>> seem to be the same but act a bit differently. >> operator shifts the sign bits and the >>> operator is used in shifting out the zero-filled bits.\nExample:"
  },
  {
    "question": "42. Which Java operator is right associative?",
    "answer": "There is only one operator which is right associative which is = operator."
  },
  {
    "question": "43. What is dot operator?",
    "answer": "The Dot operator in Java is used to access the instance variables and methods of class objects. It is also used to access classes and sub-packages from the package."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "44. What is covariant return type?",
    "answer": "The covariant return type specifies that the return type may vary in the same direction as the subclass. It’s possible to have different return types for an overriding method in the child class, but the child’s return type should be a subtype of the parent’s return type and because of that overriding method becomes variant with respect to the return type.\nWe use covariant return type because of the following reasons:\nAvoids confusing type casts present in the class hierarchy and makes the code readable, usable, and maintainable.\nGives liberty to have more specific return types when overriding methods.\nHelp in preventing run-time ClassCastExceptions on returns."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "45. What is the transient keyword?",
    "answer": "The transient keyword is used at the time of serialization if we don’t want to save the value of a particular variable in a file. When JVM comes across a transient keyword, it ignores the original value of the variable and saves the default value of that variable data type."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "46. What’s the difference between the methods sleep() and wait()?",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "47. What are the differences between String and StringBuffer?",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "48. What are the differences between StringBuffer and StringBuilder?",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "49. Which among String or String Buffer should be preferred when there are a lot of updates required to be done in the data?",
    "answer": "The string is preferred over StringBuffer as StringBuilder is faster than StringBuffer, but StringBuffer objects are the preferred over as it provides more thread safety."
  },
  {
    "question": "50. Why is StringBuffer called mutable?",
    "answer": "StringBuffer class in Java is used to represent a changeable string of characters. It offers an alternative to the immutable String class by enabling you to change a string’s contents without constantly creating new objects. Mutable (modifiable) strings are created with the help of the StringBuffer class. The StringBuffer class in Java is identical to the String class except that it is changeable.\nExample:"
  },
  {
    "question": "51. How is the creation of a String using new() different from that of a literal?",
    "answer": "String using new() is different from the literal as when we declare string it stores the elements inside the stack memory whereas when it is declared using new() it allocates a dynamic memory in the heap memory. The object gets created in the heap memory even if the same content object is present.\nSyntax:\nString x = new String(\"ABC\");"
  },
  {
    "question": "52. What is an array in Java?",
    "answer": "An Array in Java is a data structure that is used to store a fixed-size sequence of elements of the same type. Elements of an array can be accessed by their index, which starts from 0 and goes up to a length of minus 1. Array declaration in Java is done with the help of square brackets and size is also specified during the declaration. \nSyntax:\nint[] Arr = new int[5];"
  },
  {
    "question": "53. On which memory arrays are created in Java?",
    "answer": "Arrays in Java are created in heap memory. When an array is created with the help of a new keyword, memory is allocated in the heap to store the elements of the array. In Java, the heap memory is managed by the Java Virtual Machine(JVM) and it is also shared between all threads of the Java Program. The memory which is no longer in use by the program, JVM uses a garbage collector to reclaim the memory. Arrays in Java are created dynamically which means the size of the array is determined during the runtime of the program. The size of the array is specified during the declaration of the array and it cannot be changed once the array is created."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "54. What are the types of an array?",
    "answer": "There are two types of arrays i.e., Primitive arrays and References Arrays.\nSingle-Dimensional Arrays: Arrays that have only one dimension i.e., an array of integers or an array of strings are known as single-dimensional arrays.\n\nSyntax:\ndata_type[] Array_Name = new data_type[ArraySize];\n\n\n\nMulti-Dimensional Arrays: Arrays that have two or more dimensions such as two-dimensional or three-dimensional arrays."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "55. Why does the Java array index start with 0?",
    "answer": "The index of an array signifies the distance from the start of the array. So, the first element has 0 distance therefore the starting index is 0.\nSyntax:\n[Base Address + (index * no_of_bytes)]"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "56. What is the difference between int array[] and int[] array?",
    "answer": "Both int array[] and int[] array are used to declare an array of integers in java. The only difference between them is on their syntax no functionality difference is present between them.\nint arr[] is a C-Style syntax to declare an Array.\n\n\n\nint[] arr is a Java-Style syntax to declare an Array.\n\n\n\nHowever, it is generally recommended to use Java-style syntax to declare an Array. As it is easy to read and understand also it is more consistent with other Java language constructs."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "57. How to copy an array in Java?",
    "answer": "In Java there are multiple ways to copy an Array based on the requirements. \nclone() method in Java: This method in Java is used to create a shallow copy of the given array which means that the new array will share the same memory as the original array.\nint[] Arr = { 1, 2, 3, 5, 0};\nint[] tempArr = Arr.clone(); \n\n\n\narraycopy() method: To create a deep copy of the array we can use this method which creates a new array with the same values as the original array.\nint[] Arr = {1, 2, 7, 9, 8};\nint[] tempArr = new int[Arr.length];\nSystem.arraycopy(Arr, 0, tempArr, 0, Arr.length);\n\n\n\ncopyOf() method: This method is used to create a new array with a specific length and copies the contents of the original array to the new array.\nint[] Arr = {1, 2, 4, 8};\nint[] tempArr = Arrays.copyOf(Arr, Arr.length);\n\n\n\ncopyOfRange() method: This method is very similar to the copyOf() method in Java, but this method also allows us to specify the range of the elements to copy from the original array.\nint[] Arr = {1, 2, 4, 8};\nint[] temArr = Arrays.copyOfRange(Arr, 0, Arr.length);"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "58. What do you understand by the jagged array?",
    "answer": "A jagged Array in Java is just a two-dimensional array in which each row of the array can have a different length. Since all the rows in a 2-d Array have the same length but a jagged array allows more flexibility in the size of each row. This feature is very useful in conditions where the data has varying lengths or when memory usage needs to be optimized.   \nSyntax:\nint[][] Arr = new int[][] {\n    {1, 2, 8}, \n    {7, 5}, \n    {6, 7, 2, 6}\n};"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "59. Is it possible to make an array volatile?",
    "answer": "In Java, it is not possible to make a volatile. Volatile keywords in Java can only be applied to individual variables but not to arrays or collections. The value of the Variable is always read from and written to the main memory when it is defined as volatile rather than being cached in a thread’s local memory. This makes it easier to make sure that all threads that access the variable can see changes made to it."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "60. What are the advantages and disadvantages of an array?",
    "answer": ""
  },
  {
    "question": "The advantages of Arrays are:",
    "answer": "Direct and effective access to any element in the collection is made possible by arrays. An array’s elements can be accessed using an O(1) operation, which means that the amount of time needed to do so is constant and independent of the array’s size.\nData can be stored effectively in memory using arrays. The size of an array is known at compile time since its elements are stored in contiguous memory regions.\nDue to the fact that the data is stored in contiguous memory areas, arrays provide quick data retrieval.\nArrays are easy to implement and understand, making them an ideal choice for beginners learning computer programming."
  },
  {
    "question": "Disadvantages of Arrays are:",
    "answer": "Arrays are created with a predetermined size that is chosen at that moment. This means that if the array’s size needs to be extended, a new array will need to be made, and the data will need to be copied from the old array to the new array, which can take a lot of time and memory.\nThere may be unused memory space in an array’s memory space if the array is not completely occupied. If you have poor recall, this can be a problem.\nCompared to other data structures like linked lists and trees, arrays might be rigid due to their fixed size and limited support for sophisticated data types.\nBecause an array’s elements must all be of the same data type, it does not support complex data types like objects and structures."
  },
  {
    "question": "61. What is an object-oriented paradigm?",
    "answer": "Paradigm literally means a pattern or a method. Programming paradigms are the methods to solve a program that is of four types namely, Imperative, logical, functional, and object-oriented. When objects are used as base entities upon which the methods are applied, encapsulation or inheritance functionalities are performed, it is known as an object-oriented paradigm."
  },
  {
    "question": "62. What are the main concepts of OOPs in Java?",
    "answer": "The main concepts of OOPs in Java are mentioned below:\nInheritance\nPolymorphism\nAbstraction\nEncapsulation"
  },
  {
    "question": "63. What is the difference between an object-oriented programming language and an object-based programming language?",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "64. How is the ‘new’ operator different from the ‘newInstance()’ operator in Java?",
    "answer": "the new operator is used to create objects, but if we want to decide the type of object to be created at runtime, there is no way we can use the new operator. In this case, we have to use the newInstance() method."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "65. What are Classes in Java? ",
    "answer": "In Java, Classes are the collection of objects sharing similar characteristics and attributes. Classes represent the blueprint or template from which objects are created.  Classes are not real-world entities but help us to create objects which are real-world entities."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "66. What is the difference between static (class) method and instance method?",
    "answer": ""
  },
  {
    "question": "67. What is this keyword in Java?",
    "answer": "‘this’ is a keyword used to reference a variable that refers to the current object."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "68. What are Brief Access Specifiers and Types of Access Specifiers?",
    "answer": "Access Specifiers in Java help to restrict the scope of a class, constructor, variable, method, or data member. There are four types of Access Specifiers in Java mentioned below:\nPublic\nPrivate\nProtected\nDefault"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "69. What will be the initial value of an object reference which is defined as an instance variable?",
    "answer": "The initial value of an object reference which is defined as an instance variable is a NULL value."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "70. What is an object?",
    "answer": "The object is a real-life entity that has certain properties and methods associated with it. The object is also defined as the instance of a class. An object can be declared using a new keyword."
  },
  {
    "question": "71. What are the different ways to create objects in Java?",
    "answer": "Methods to create objects in Java are mentioned below:\nUsing new keyword\nUsing new instance\nUsing clone() method\nUsing deserialization\nUsing the newInstance() method of the Constructor class\nTo know more about methods to create objects in Java refer to this article."
  },
  {
    "question": "72. What are the advantages and disadvantages of object cloning?",
    "answer": "There are many advantages and disadvantages of using object cloning as mentioned below:\nAdvantages:\nIn Java, the ‘=’ assignment operator cannot be used for cloning as it simply creates a copy of reference variables. To overcome such discrepancy the clone() method of Object class can be used over the assignment operator.\nThe clone() method is a protected method of class Object which means that only the Employee class can clone Employee objects. This means no class other than Employee can clone Employee objects since it does not know the Employee class’ attributes.\nCode size decreases as repetition decreases. \nAllows replication (kind of like prototype pattern) manually initilizing each field creates large code if object is complex, its faster with cloning.\nDisadvantages:\nAs the Object.clone() method is protected, so need to provide our own clone() and indirectly call Object.clone() from it.\nIf we don’t have any methods then we need to provide a Cloneable interface as we need to provide JVM information so that we can perform a clone() on our object.if not, we cant clone clone does shallow copy of fields if we just return super.clone() from clone method that can be problematic."
  },
  {
    "question": "73. What are the advantages of passing this into a method instead of the current class object itself?",
    "answer": "There are a few advantages of passing this into a method instead of the current class object itself these are:\nthis is the final variable because of which this cannot be assigned to any new value whereas the current class object might not be final and can be changed.\nthis can be used in the synchronized block."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "74. What is the constructor?",
    "answer": "Constructor is a special method that is used to initialize objects. Constructor is called when a object is created. The name of constructor is same as of the class.\nExample:\n// Class Created\nclass XYZ{\n      private int val;\n      \n      // Constructor\n      XYZ(){\n            val=0;\n      }\n};"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "75. What happens if you don’t provide a constructor in a class?",
    "answer": "If you don’t provide a constructor in a class in Java, the compiler automatically generates a default constructor with no arguments and no operation which is a default constructor."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "76. How many types of constructors are used in Java?",
    "answer": "There are two types of constructors in Java as mentioned below:\nDefault Constructor\nParameterized Constructor\nDefault Constructor: It is the type that does not accept any parameter value. It is used to set initial values for object attributes.\nclass_Name();\n// Default constructor called\n\n\n\nParameterized Constructor: It is the type of constructor that accepts parameters as arguments. These are used to assign values to instance variables during the initialization of objects.\nclass_Name(parameter1, parameter2......);\n// All the values passed as parameter will be\n// allocated accordingly"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "77. What is the purpose of a default constructor?",
    "answer": "Constructors help to create instances of a class or can be said to create objects of a class. Constructor is called during the initialization of objects. A default constructor is a type of constructor which do not accept any parameter, So whatever value is assigned to properties of the objects are considered default values."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "78. What do you understand by copy constructor in Java?",
    "answer": "The copy constructor is the type of constructor in which we pass another object as a parameter because which properties of both objects seem the same, that is why it seems as if constructors create a copy of an object."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "79. Where and how can you use a private constructor?",
    "answer": "A private constructor is used if you don’t want any other class to instantiate the object to avoid subclassing. The use private constructor can be seen as implemented in the example.\nExample:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "80. What are the differences between the constructors and methods?",
    "answer": "Java constructors are used for initializing objects. During creation, constructors are called to set attributes for objects apart from this few basic differences between them are:\nConstructors are only called when the object is created but other methods can be called multiple times during the life of an object.\nConstructors do not have a return type, whereas methods have a return type, which can be void or any other type.\nConstructors are used to setting up the initial state but methods are used to perform specific actions."
  },
  {
    "question": "81. What is an Interface?",
    "answer": "An interface in Java is a collection of static final variables and abstract methods that define the contract or agreement for a set of linked classes. Any class that implements an interface is required to implement a specific set of methods. It specifies the behavior that a class must exhibit but not the specifics of how it should be implemented.\nSyntax:\ninterface \n{\n    // constant fields\n    // methds that are abstract by default\n}\n\n\n\nExample:"
  },
  {
    "question": "82. Give some features of the Interface.",
    "answer": "An Interface in Java programming language is defined as an abstract type used to specify the behavior of a class. An interface in Java is a blueprint of a behavior. A Java interface contains static constants and abstract methods.\nFeatures of the Interface are mentioned below:\nThe interface can help to achieve total abstraction.\nAllows us to use multiple inheritances in Java.\nAny class can implement multiple interfaces even when one class can extend only one class.\nIt is also used to achieve loose coupling."
  },
  {
    "question": "83. What is a marker interface?",
    "answer": "An Interface is recognized as an empty interface (no field or methods) it is called a marker interface. Examples of marker interfaces are Serializable, Cloneable, and Remote interfaces."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "84. What are the differences between abstract class and interface?",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "85. What do you mean by data encapsulation?",
    "answer": "Data Encapsulation is the concept of OOPS properties and characteristics of the classes that The interface is binded together. Basically, it bundles data and methods that operate on that data within a single unit. Encapsulation is achieved by declaring the instance variables of a class as private, which means they can only be accessed within the class."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "86. What are the advantages of Encapsulation in Java?",
    "answer": "The advantages of Encapsulation in Java are mentioned below:\nData Hiding:  it is a way of restricting the access of our data members by hiding the implementation details. Encapsulation also provides a way for data hiding. The user will have no idea about the inner implementation of the class. \nIncreased Flexibility: We can make the variables of the class read-only or write-only depending on our requirements. \nReusability: Encapsulation also improves the re-usability and is easy to change with new requirements.\nTesting code is easy: Code is made easy to test for unit testing."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "87. What is the primary benefit of Encapsulation? ",
    "answer": "The main advantage of Encapsulation in Java is its ability to protect the internal state of an object from external modification or access. It is the is a way of hiding the implementation details of a class from outside access and only exposing a public interface that can be used to interact with the class. The main benefit is of providing a way to control and manage the state and the behavior of an object and also protecting it from modification and unauthorized access at the same time. \nExample:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "88. What do you mean by aggregation?",
    "answer": "Aggregation is a term related to the relationship between two classes best described as a “has-a” relationship. This kind is the most specialized version of association. It is a unidirectional association means it is a one-way relationship. It contains the reference to another class and is said to have ownership of that class."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "89. What is the ‘IS-A ‘ relationship in OOPs Java?",
    "answer": "‘IS-A’ is a type of relationship in OOPs Java where one class inherits another class."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "90. Define Inheritance.",
    "answer": "When an object that belongs to a subclass acquires all the properties and behavior of a parent object that is from the superclass, it is known as inheritance.  A class within a class is called the subclass and the latter is referred to as the superclass. Sub class or the child class is said to be specific whereas the superclass or the parent class is generic. Inheritance provides code reusability."
  },
  {
    "question": "91. What are the different types of inheritance in Java?",
    "answer": "Inheritance is the method by which the Child class can inherit the features of the Super or Parent class. In Java, Inheritance is of four types:\nSingle Inheritance: When a child or subclass extends only one superclass, it is known to be single inheritance. Single-parent class properties are passed down to the child class. \nMultilevel Inheritance: When a child or subclass extends any other subclass a hierarchy of inheritance is created which is known as multilevel inheritance. In other words, one subclass becomes the parent class of another.\nHierarchical Inheritance: When multiple subclasses derive from the same parent class is known as Hierarchical Inheritance. In other words, a class that has a single parent has many subclasses.\nMultiple Inheritance: When a child class inherits from multiple parent classes is known as Multiple Inheritance. In Java, it only supports multiple inheritance of interfaces, not classes."
  },
  {
    "question": "92. What is multiple inheritance? Is it supported by Java?",
    "answer": "A component of the object-oriented notion known as multiple inheritances allows a class to inherit properties from many parent classes. When methods with the same signature are present in both superclasses and subclasses, an issue arises. The method’s caller cannot specify to the compiler which class method should be called or even which class method should be given precedence."
  },
  {
    "question": "93. How is inheritance in C++ different from Java?",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "94. Is there any limitation to using Inheritance?",
    "answer": "Yes, there is a limitation of using Inheritance in Java, as because of inheritance one can inherit everything from super class and interface because of which subclass is too clustered and sometimes error-prone when dynamic overriding or dynamic overloading is done in certain situations."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "95. Although inheritance is a popular OOPs concept, it is less advantageous than composition. Explain.",
    "answer": "Inheritance is a popular concept of Object-Oriented Programming (OOP), in which a class can inherit the properties and methods from any other class, which is referred to as a Parent or superclass. On the other hand in Composition, a class can contain an instance of another class as a member variable which is often referred to as part or a component. Below are some reasons why composition is more advantageous than inheritance:\nTight Coupling: Whenever any changes are made to the superclass, these changes can affect the behavior of all its child or Subclasses. This problem makes code less flexible and also creates issues during maintenance. This problem also leads to the Tight coupling between the classes.\nFragile Base Class Problem: When the changes to the base class can break the functionality of its derived classes. This problem can make it difficult to add new features or modify the existing ones. This problem is known as the Fragile Base class problem.\nLimited Reuse: Inheritance in Java can lead to limited code reuse and also code duplication. As a subclass inherits all the properties and methods of its superclass, sometimes it may end up with unnecessary code which is not needed. This leads to a less maintainable codebase."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "96. What is an association?",
    "answer": "The association is a relation between two separate classes established through their Objects. It represents Has-A’s relationship."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "97. What do you mean by aggregation?",
    "answer": "Composition is a restricted form of Aggregation in which two entities are highly dependent on each other. It represents part-of the relationship."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "98. What is the composition of Java?",
    "answer": "Composition implies a relationship where the child cannot exist independently of the parent. For example Human heart, the heart doesn’t exist separately from a Human."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "99. State the difference between Composition and Aggregation.",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "100. Can the constructor be inherited?",
    "answer": "No, we can’t inherit a constructor."
  },
  {
    "question": "\n101. What is Polymorphism?",
    "answer": "Polymorphism is defined as the ability to take more than one form It is of two types namely, Compile time polymorphism or method overloading- a function called during compile time. For instance, take a class ‘area’. Based on the number of parameters it may calculate the area of a square, triangle, or circle. Run time polymorphism or method overriding- links during run time.  The method inside a class overrides the method of the parent class."
  },
  {
    "question": "102. What is runtime polymorphism or dynamic method dispatch?",
    "answer": "Dynamic method dispatch is a resolving mechanism for method overriding during the run time. Method overriding is the one where the method in a subclass has the same name, parameters, and return type as a method in the superclass. When the over-ridden method is called through a superclass reference, java determines which version (superclass or subclass) of that method is to be executed based upon the type of an object being referred to at the time the call occurs. Thus the decision is made at run time. This is referred to as dynamic method dispatch."
  },
  {
    "question": "103. What is method overriding?",
    "answer": "Method overriding, also known as run time polymorphism is one where the child class contains the same method as the parent class. For instance, we have a method named ‘gfg()’ in the parent class. A method gfg() is again defined in the sub-class. Thus when gfg() is called in the subclass, the method within the class id executed. Here, gfg() within the class overridden the method outside."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "104. What is method overloading?",
    "answer": "Method overriding is a method to achieve Run-time polymorphism in Java. Method overriding is a feature that allows a child class to provide a specific implementation of a method that is already provided by one of its parent classes. When a method in a child class has the same name, the same parameters or signature, and the same return type(or sub-type) as a method in its parent class, then the method in the subclass is said to override the method in the superclass."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "105. Can we override the static method?",
    "answer": "No, as static methods are part of the class rather than the object so we can’t override them."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "106. Can we override the overloaded method?",
    "answer": "Yes, since the overloaded method is a completely different method in the eyes of the compiler. Overriding isn’t the same thing at all. The decision as to which method to call is deferred to runtime."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "107. Can we overload the main() method?",
    "answer": "Yes in Java we can overload the main method to call the main method with the help of its predefined calling method."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "108. What are method overloading and method overriding?",
    "answer": "Method Overloading: It is also known as Compile Time Polymorphism. In method overloading two or more methods are shared in the same class with a different signature. \nExample:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "109. Can we override the private methods?",
    "answer": "It is not possible to override the private methods in Java. Method overriding is where the method in the subclass is implemented instead of the method from the parent class. The private methods are accessible only within the class in which it is declared. Since this method is not visible to other classes and cannot be accessed, it cannot be overridden."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "110. Can we change the scope of the overridden method in the subclass?",
    "answer": "In Java, it is not possible to modify the overridden method’s scope. The subclass method’s scope must be equal to or wider than the Superclass method’s overridden method’s scope. The overridden method in the subclass, for instance, can have a public scope or a more accessible scope like protected or default if the overridden method in the superclass has a public scope. It cannot, however, have a more exclusive scope like private."
  },
  {
    "question": "111. Can we modify the throws clause of the superclass method while overriding it in the subclass?",
    "answer": "We can modify the throws clause of the Superclass method with some limitations, we can change the throws clause of the superclass method while overriding it in the subclass. The subclass overridden method can only specify unchecked exceptions if the superclass method does not declare any exceptions. If the superclass method declares an exception, the subclass method can declare the same exception, a subclass exception, or no exception at all. However, the subclass method cannot declare a parent exception that is broader than the ones declared in the superclass method."
  },
  {
    "question": "112. Can you have virtual functions in Java?",
    "answer": "Yes, Java supports virtual functions. Functions are by default virtual and can be made non-virtual using the final keyword."
  },
  {
    "question": "113. What is Abstraction?",
    "answer": "Abstraction refers to the act of representing essential features without including background details. The detailed information or the implementation is hidden. The most common example of abstraction is a car, we know how to turn on the engine, accelerate and move, however, the way engine works, and its internal components are complex logic hidden from the general users. This is usually done to handle the complexity."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "114. What is Abstract class?",
    "answer": "A class declared as abstract, cannot be instantiated i.e., the object cannot be created. It may or may not contain abstract methods but if a class has at least one abstract method, it must be declared abstract.\nExample of an abstract class with abstract method:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "115. When Abstract methods are used?",
    "answer": "An abstract method is used when we want to use a method but want to child classes to decide the implementation in that case we use Abstract methods with the parent classes."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "116. How can you avoid serialization in the child class if the base class is implementing the Serializable interface?",
    "answer": "Serialization in the child class if the base class is implementing the Serializable interface then we can avoid it by defining the writeObject() method and throwing NotSerializableException()."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "117. What is Collection Framework in Java?",
    "answer": "Collections are units of objects in Java. The collection framework is a set of interfaces and classes in Java that are used to represent and manipulate collections of objects in a variety of ways. The collection framework contains classes(ArrayList, Vector, LinkedList, PriorityQueue, TreeSet) and multiple interfaces (Set, List, Queue, Deque) where every interface is used to store a specific type of data."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "118. Explain various interfaces used in the Collection framework.",
    "answer": "Collection framework implements\nCollection Interface\nList Interface\nSet Interface\nQueue Interface\nDeque Interface\nMap Interface\nCollection interface: Collection is the primary interface available that can be imported using java.util.Collection.\nSyntax:\npublic interface Collection<E> extends iterable"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "119. How can you synchronize an ArrayList in Java?",
    "answer": "An ArrayList can be synchronized using two methods mentioned below:\nUsing Collections.synchronizedList()\nUsing CopyOnWriteArrayList\nUsing Collections.synchronizedList():\npublic static List<T> synchronizedList(List<T> list)\n\n\n\nUsing CopyOnWriteArrayList:\nCreate an empty List.\nIt implements the List interface\nIt is a thread-safe variant of ArrayList\nT represents generic"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "120. Why do we need a synchronized ArrayList when we have Vectors (which are synchronized) in Java?",
    "answer": "ArrayList is in need even when we have Vectors because of certain reasons:\nArrayList is faster than Vectors.\nArrayList supports multithreading whereas Vectors only supports single-thread use.\nArrayList is safer to use, as Vectors supports single threads and individual operations are less safe and take longer to synchronize.\nVectors are considered outdated in Java because of their synchronized nature."
  },
  {
    "question": "121. Why can’t we create a generic array?",
    "answer": "Generic arrays can’t be created because an array carries type information of its elements at runtime because of which during runtime it throw ‘ArrayStoreException’ if the elements’ type is not similar. Since generics type information gets erased at compile time by Type Erasure, the array store check would have been passed where it should have failed."
  },
  {
    "question": "122. Contiguous memory locations are usually used for storing actual values in an array but not in ArrayList. Explain.",
    "answer": "The elements of an array are stored in contiguous memory locations, which means that each element is stored in a separate block based on it located within the array. Since the elements of the array are stored in contiguous locations, it can be relatively easy to access any element by its index, as the element address can be calculated based on the location of the element. But Java implements ArrayLists as dynamic arrays, which means that the size can change as elements are removed or added. ArrayList elements are not stored in contiguous memory locations in order to accommodate this dynamic nature. Instead, the ArrayList makes use of a method known as an expandable array in which the underlying array is expanded to a larger size as needed and the elements are then copied to the new location. In contrast to an ArrayList, which has a dynamic size and does not store its elements in contiguous memory locations, an array has a fixed size and its elements are stored there."
  },
  {
    "question": "123. Explain the method to convert ArrayList to Array and Array to ArrayList.",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "124. How does the size of ArrayList grow dynamically? And also state how it is implemented internally.",
    "answer": "Due to ArrayLists array-based nature, it grows dynamically in size ensuring that there is always enough room for elements. When an ArrayList element is first created, the default capacity is around 10-16 elements which basically depends on the Java version. ArrayList elements are copied over from the original array to the new array when the capacity of the original array is full. As the ArrayList size increases dynamically, the class creates a new array of bigger sizes and it copies all the elements from the old array to the new array. Now, the reference of the new array is used internally. This process of dynamically growing an array is known as resizing."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "125. What is a Vector in Java?",
    "answer": "Vectors in Java are similar and can store multiple elements inside them. Vectors follow certain rules mentioned below:\nVector can be imported using Java.util.Vector.\nVector is implemented using a dynamic array as the size of the vector increases and decreases depending upon the elements inserted in it. \nElements of the Vector using index numbers.\nVectors are synchronized in nature means they only used a single thread ( only one process is performed at a particular time ).\nThe vector contains many methods that are not part of the collections framework.\nSyntax:\nVector gfg = new Vector(size, increment);"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "126. How to make Java ArrayList Read-Only?",
    "answer": "An ArrayList can be made ready only using the method provided by Collections using the Collections.unmodifiableList() method. \nSyntax:\narray_readonly = Collections.unmodifiableList(ArrayList);\n\n\n\nExample:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "127. What is a priority queue in Java?",
    "answer": "A priority queue is an abstract data type similar to a regular queue or stack data structure. Elements stored in elements are depending upon the priority defined from low to high. The PriorityQueue is based on the priority heap.\nSyntax:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "128. Explain the LinkedList class.",
    "answer": "LinkedList class is Java that uses a doubly linked list to store elements. It inherits the AbstractList class and implements List and Deque interfaces. Properties of the LinkedList Class are mentioned below:\nLinkedList classes are non-synchronized.\nMaintains insertion order.\nIt can be used as a list, stack, or queue.\nSyntax:\nLinkedList<class> list_name=new LinkedList<class>();"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "129. What is the Stack class in Java and what are the various methods provided by it?",
    "answer": "A Stack class in Java is a LIFO data structure that implements the Last In First Out data structure. It is derived from a Vector class but has functions specific to stacks. The Stack class in java provides the following methods:\npeek(): returns the top item from the stack without removing it\nempty(): returns true if the stack is empty and false otherwise\npush(): pushes an item onto the top of the stack\npop(): removes and returns the top item from the stack\nsearch(): returns the 1, based position of the object from the top of the stack. If the object is not in the stack, it returns -1"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "130. What is Set in the Java Collections framework and list down its various implementations?",
    "answer": "Sets are collections that don’t store duplicate elements. They don’t keep any order of the elements. The Java Collections framework provides several implementations of the Set interface, including:\nHashSet: HashSet in Java, stores the elements in a has table which provides faster lookups and faster insertion. HashSet is not ordered.\nLinkedHashSet: LinkedHashSet is an implementation of HashSet which maintains the insertion order of the elements.\nTreeSet: TreeSet stores the elements in a sorted order that is determined by the natural ordering of the elements or by a custom comparator provided at the time of creation."
  },
  {
    "question": "131. What is the HashSet class in Java and how does it store elements?",
    "answer": "The HashSet class implements the Set interface in the Java Collections Framework and is a member of the HashSet class. Unlike duplicate values, it stores a collection of distinct elements. In this implementation, each element is mapped to an index in an array using a hash function, and the index is used to quickly access the element. It produces an index for the element in the array where it is stored based on the input element. Assuming the hash function distributes the elements among the buckets appropriately, the HashSet class provides constant-time performance for basic operations (add, remove, contain, and size)."
  },
  {
    "question": "132. What is LinkedHashSet in Java Collections Framework?",
    "answer": "The LinkedHashSet is an ordered version of Hashset maintained by a doubly-linked List across all the elements. It is very helpful when iteration order is needed. During Iteration in LinkedHashSet, elements are returned in the same order they are inserted.\nSyntax: \nLinkedHashSet<E> hs = new LinkedHashSet<E>();\n\n\n\nExample:"
  },
  {
    "question": "133. What is a Map interface in Java?",
    "answer": "The map interface is present in the Java collection and can be used with Java.util package. A map interface is used for mapping values in the form of a key-value form. The map contains all unique keys. Also, it provides methods associated with it like containsKey(), contains value (), etc. \nThere are multiple types of maps in the map interface as mentioned below:\nSortedMap\nTreeMap\nHashMap\nLinkedHashMap"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "134. Explain Treemap in Java",
    "answer": "TreeMap is a type of map that stores data in the form of key-value pair. It is implemented using the red-black tree. Features of TreeMap are :\nIt contains only unique elements.\nIt cannot have a NULL key \nIt can have multiple NULL values.\nIt is non-synchronized.\nIt maintains ascending order."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "135. What is EnumSet?",
    "answer": "EnumSet is a specialized implementation of the Set interface for use with enumeration type. A few features of EnumSet are:\nIt is non-synchronized.\nFaster than HashSet.\nAll of the elements in an EnumSet must come from a single enumeration type.\nIt doesn’t allow null Objects and throws NullPointerException for exceptions.\nIt uses a fail-safe iterator.\nSyntax:\npublic abstract class EnumSet<E extends Enum<E>> \n\n\n\nParameter: E specifies the elements."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "136. What is BlockingQueue?",
    "answer": "A blocking queue is a Queue that supports the operations that wait for the queue to become non-empty while retrieving and removing the element, and wait for space to become available in the queue while adding the element.\nSyntax:\npublic interface BlockingQueue<E> extends Queue<E>\n\n\n\nParameters: E is the type of elements stored in the Collection"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "137. What is the ConcurrentHashMap in Java and do you implement it?",
    "answer": "ConcurrentHashMap is implemented using Hashtable.\nSyntax:\npublic class ConcurrentHashMap<K, ​V> \nextends AbstractMap<K, ​V> \nimplements ConcurrentMap<K, ​V>, Serializable\n\n\n\nParameters: K is the key Object type and V is the value Object type"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "138. Can you use any class as a Map key?",
    "answer": "Yes, we can use any class as a Map Key if it follows certain predefined rules mentioned below:\nThe class overriding the equals() method must also override the hashCode() method\nThe concurrentHashMap class is thread-safe.\nThe default concurrency level of ConcurrentHashMap is 16.\nInserting null objects in ConcurrentHashMap is not possible as a key or as value."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "139. What is an Iterator?",
    "answer": "The Iterator interface provides methods to iterate over any Collection in Java. Iterator is the replacement of Enumeration in the Java Collections Framework. It can get an iterator instance from a Collection using the _iterator()_ method.  It also allows the caller to remove elements from the underlying collection during the iteration."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "140. What is an enumeration?",
    "answer": "Enumeration is a user-defined data type. It is mainly used to assign names to integral constants, the names make a program easy to read and maintain. The main objective of the enum is to define user-defined data types.\nExample:\n// A simple enum example where enum is declared \n// outside any class (Note enum keyword instead of \n// class keyword) \nenum Color \n{ \n    RED, GREEN, BLUE; \n}"
  },
  {
    "question": "141. What is the difference between Collection and Collections?",
    "answer": ""
  },
  {
    "question": "142. Differentiate between Array and ArrayList in Java.",
    "answer": ""
  },
  {
    "question": "143. What is the difference between Array and Collection in Java?",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "144. Difference between ArrayList and LinkedList.",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "145. Differentiate between ArrayList and Vector in Java.",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "146. What is the difference between Iterator and ListIterator?",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "147. Differentiate between HashMap and HashTable.",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "148. What is the difference between Iterator and Enumeration?",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "149. What is the difference between Comparable and Comparator?",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "150. What is the difference between Set and Map?",
    "answer": ""
  },
  {
    "question": "151. Explain the FailFast iterator and FailSafe iterator along with examples for each.",
    "answer": "A FailFast iterator is an iterator that throws a ConcurrentModificationException if it detects that the underlying collection has been modified while the iterator is being used. This is the default behavior of iterators in the Java Collections Framework. For example, the iterator for a HashMap is FailFast.\nExample:"
  },
  {
    "question": "152. What is Exception Handling?",
    "answer": "An Exception is an Event that interrupts the normal flow of the program and requires special processing. During the execution of a program, errors and unplanned occurrences can be dealt with by using the Java Exception Handling mechanism. Below are some reasons why Exceptions occur in Java:\nDevice failure\nLoss of Network Connection\nCode Errors\nOpening an Unavailable file\nInvalid User Input\nPhysical Limitations (out of disk memory)"
  },
  {
    "question": "153. How many types of exceptions can occur in a Java program?",
    "answer": "There are generally two types of exceptions in Java:\nBuilt-in Exceptions: Built-in exceptions in Java are provided by the Java Libraries. These exceptions can be further divided into two subcategories i.e., checked and unchecked Exceptions. Below are some of the built-in exceptions in Java:\nArrayIndexOutOfBoundsExceptions\nClassNotFoundException\nFileNotFoundException\nIOException\nNullPointerException\nArithmeticException\nInterruptedException\nRuntimeException\nArrayIndexOutOfBoundsExceptions\nClassNotFoundException\nFileNotFoundException\nIOException\nNullPointerException\nArithmeticException\nInterruptedException\nRuntimeException\nUser-Defined Exceptions: User-defined exceptions are defined by the programmers themselves to handle some specific situations or errors which are not covered by built-in exceptions. To define user-defined exceptions a new class that extends the appropriate exception class must be defined. User-defined Exceptions in Java are used when the built-in exceptions are in Java."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "154. Difference between an Error and an Exception.",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "155. Explain the hierarchy of Java Exception classes.",
    "answer": "All exception and error types in Java are subclasses of the class throwable, which is the base class of the hierarchy. This class is then used for exceptional conditions that user programs should catch. NullPointerException is an example of such an exception. Another branch, error is used by the Java run-time system to indicate errors having to do with the JRE. StackOverflowError is an example of one of such error."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "156. Explain Runtime Exceptions.",
    "answer": "Runtime Exceptions are exceptions that occur during the execution of a code, as opposed to compile-time exceptions that occur during compilation. Runtime exceptions are unchecked exceptions, as they aren’t accounted for by the JVM.\nExamples of runtime exceptions in Java include:\nNullPointerException: This occurs when an application attempts to use a null object reference.\nArrayIndexOutOfBoundsException: This occurs when an application attempts to access an array index that is out of bounds.\nArithmeticException: This occurs when an application attempts to divide by zero.\nIllegalArgumentException: This occurs when a method is passed on an illegal or inappropriate argument.\nUnlike checked exceptions, runtime exceptions do not require a declaration in the throws clause or capture in a try-catch block. However, handling runtime exceptions is advisable in order to provide meaningful error messages and prevent a system crash. Because runtime exceptions provide more specific information about the problem than checked exceptions, they enable developers to detect and correct programming errors more easily and quickly."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "157. What is NullPointerException?",
    "answer": "It is a type of run-time exception that is thrown when the program attempts to use an object reference that has a null value. The main use of NullPointerException is to indicate that no value is assigned to a reference variable, also it is used for implementing data structures like linked lists and trees."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "158. When is the ArrayStoreException thrown?",
    "answer": "ArrayStoreException is thrown when an attempt is made to store the wrong type of object in an array of objects.\nExample:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "159. What is the difference between Checked Exception and Unchecked Exception?",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "160. What is the base class for Error and Exception?",
    "answer": "Error is an illegal operation performed by the user which causes abnormality in the program. Exceptions are the unexpected events or conditions that comes while running the program, exception disrupts the normal flow of the program’s instructions.\nErrors and Exceptions both have a common parent class which is java.lang.Throwable class."
  },
  {
    "question": "161. Is it necessary that each try block must be followed by a catch block?",
    "answer": "No, It is not necessary to use catch block after try block in Java as we can create another combination with finally block. Finally is the block which runs despite the fact that the exception is thrown or not."
  },
  {
    "question": "162. What is exception propagation?",
    "answer": "Exception propagation is a process in which the exception is dropped from to the top to the bottom of the stack. If not caught once, the exception again drops down to the previous method, and so on until it gets caught or until it reaches the very bottom of the call stack."
  },
  {
    "question": "163. What will happen if you put System.exit(0) on the try or catch block? Will finally block execute?",
    "answer": "System.exit(int) has the capability to throw SecurityException. So, if in case of security, the exception is thrown then finally block will be executed otherwise JVM will be closed while calling System. exit(0) because of which finally block will not be executed."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "164. What do you understand by Object Cloning and how do you achieve it in Java?",
    "answer": "It is the process of creating an exact copy of any object. In order to support this, a java class has to implement the Cloneable interface of java.lang package and override the clone() method provided by the Object class the syntax of which is:\nProtected Object clone() throws CloneNotSupportedException{ return (Object)super.clone();}In case the Cloneable interface is not implemented and just the method is overridden, it results in CloneNotSupportedException in Java."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "165. How do exceptions affect the program if it doesn’t handle them?",
    "answer": "Exceptions are responsible for abruptly terminating the running of the program while executing and the code written after the exception occurs is not executed."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "166. What is the use of the final keyword?",
    "answer": "The final keyword is used to make functions non-virtual. By default, all the functions are virtual so to make it non-virtual we use the final keyword."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "167. What purpose do the keywords final, finally, and finalize fulfill?",
    "answer": ""
  },
  {
    "question": "i). final:",
    "answer": "final is a keyword is used with the variable, method, or class so that they can’t be overridden. \nExample:"
  },
  {
    "question": "ii). finally",
    "answer": "finally is a block of code used with “try-catch” in exception handling. Code written in finally block runs despite the fact exception is thrown or not.\nExample:"
  },
  {
    "question": "iii). finalize",
    "answer": "It is a method that is called just before deleting/destructing the objects which are eligible for Garbage collection to perform clean-up activity.\nExample:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "168. What is the difference between this() and super() in Java?",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "169. What is multitasking?",
    "answer": "Multitasking in Java refers to a program’s capacity to carry out several tasks at once. Threads, which are quick operations contained within a single program, can do this. Executing numerous things at once is known as multitasking.\nExample:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "170. What do you mean by a Multithreaded program?",
    "answer": "Multithreaded programs in Java contain threads that run concurrently instead of running sequentially. A computer can use its resources more efficiently by combining multiple tasks at once. Any program with multithreading allows more than one user to simultaneously use the program without running multiple copies. A multithreaded program is designed to run multiple processes at the same time which can improve the performance of a program and allows the program to utilize multiple processors and improves the overall throughput."
  },
  {
    "question": "171. What are the advantages of multithreading?",
    "answer": "There are multiple advantages of using multithreading which are as follows:\nResponsiveness: User Responsiveness increases because multithreading interactive application allows running code even when the section is blocked or executes a lengthy process.\nResource Sharing: The process can perform message passing and shared memory because of multithreading.\nEconomy: We are able to share memory because of which the processes are economical.\nScalability: Multithreading on multiple CPU machines increases parallelism.\nBetter Communication: Thread synchronization functions improves inter-process communication.\nUtilization of multiprocessor architecture\nMinimized system resource use"
  },
  {
    "question": "172. What are the two ways in which Thread can be created?",
    "answer": "Multithreading is a Java feature that allows concurrent execution of two or more parts of a program for maximum utilization of the CPU. In general, threads are small, lightweight processes with separate paths of execution. These threads use shared memory, but they act independently, thus if any one thread fails it does not affect the other threads. There are two ways to create a thread:\nBy extending the Thread class\nBy implementing a Runnable interface."
  },
  {
    "question": "173. What is a thread?",
    "answer": "Threads in Java are subprocess with lightweight with the smallest unit of processes and also has separate paths of execution. These threads use shared memory but they act independently hence if there is an exception in threads that do not affect the working of other threads despite them sharing the same memory. A thread has its own program counter, execution stack, and local variables, but it shares the same memory space with other threads in the same process. Java provides built-in support for multithreading through the Runnable interface and the Thread class."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "174. Differentiate between process and thread?",
    "answer": "A process and a thread are both units of execution in a computer system, but they are different in several ways:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "175. Describe the life cycle of the thread?",
    "answer": "A thread in Java at any point in time exists in any one of the following states. A thread lies only in one of the shown states at any instant: \nNew: The thread has been created but has not yet started.\nRunnable: The thread is running, executing its task, or is ready to run if there are no other higher-priority threads.\nBlocked: The thread is temporarily suspended, waiting for a resource or an event.\nWaiting: The thread is waiting for another thread to perform a task or for a specified amount of time to elapse.\nTerminated: The thread has completed its task or been terminated by another thread."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "176. Explain suspend() method under the Thread class.",
    "answer": "The suspend() method of the Thread class in Java temporarily suspends the execution of a thread. When a thread is suspended it goes into a blocked state and it would not be scheduled by the operating system which means that it will not be able to execute its task until it is resumed. There are more safer and flexible alternatives to the suspend() methods in the modern java programming language. This method does not return any value.\nSyntax:\npublic final void suspend();\n\n\n\nExample:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "177. Explain the main thread under Thread class execution.",
    "answer": "Java provides built-in support for multithreaded programming. The main thread is considered the parent thread of all the other threads that are created during the program execution. The main thread is automatically created when the program starts running. This thread executes the main method of the program. It is responsible for executing the main logic of the Java program as well as handling the user input operations. The main thread serves as the base thread from which all other child threads are spawned."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "178. What is a daemon thread?",
    "answer": "A daemon thread in Java is a low-priority thread that is used to perform background operations or tasks which are used to perform continuously. such as Garbage collection, Signal dispatches, Action listeners, etc. Daemon threads in Java have lower priority than user threads, which means they can only execute when no user threads are running. Daemon threads in Java are useful features that are required for background tasks that do not require explicit shutdown or finalization. It allows more efficient use of system resource and are used to simplify resources and can simplify long-running tasks."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "179. What are the ways in which a thread can enter the waiting state?",
    "answer": "Thread is a lightweight process that runs concurrently with the other thread inside a single process. Each thread can execute a different task and share the resources within a single process. Thread in Java can enter the waiting state in many different ways:\nSleep() method Call: The sleep () method is used to pause the execution of the thread for a specific amount of time. While the thread is paused it goes into the waiting state.\nWait() method: This method is used to wait a thread until the other thread signals it to wake up. Thread goes into the waiting state until it receives a notification from another thread.\nJoin() method: Join() method can be used to wait for thread to finish the execution. Calling thread goes into the waiting state until the target thread is completed.\nWaiting for I/O operations: If the thread is waiting for Input/Output operation to complete, it goes into the waiting state until the operation is finished.\nSynchronization Issues: If there are any synchronization issues in a multi-threaded application, threads may go into the waiting state until the synchronization issues are resolved."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "180. How does multi-threading take place on a computer with a single CPU?",
    "answer": "Java uses a technique called time-sharing, commonly referred to as time-slicing, to implement multi-threading on computers with a single CPU. The appearance of parallel execution is created by the CPU switching between active threads. The operating system is in charge of allocating CPU time to each thread sequentially and scheduling the threads.\nIn order to stop threads from interacting with one another and creating race situations or other issues, Java has a number of ways to govern the behavior of threads, including synchronization and locking. It is feasible to create multi-threaded programmers that operate correctly and effectively on a machine with a single CPU by regulating the interaction between threads and making sure that crucial code parts are synchronized. In contrast to running the same program on a computer with multiple CPUs or cores, multi-threading on a single CPU can only give the appearance of parallelism, and actual performance gains may be modest. The operating system divides the CPU time that is available when numerous threads are running on a single CPU into small time slices and gives each thread a time slice to execute. Rapid switching between the threads by the operating system creates the appearance of parallel execution. The switching between threads appears to be immediate because the time slices are often very tiny, on the order of milliseconds or microseconds."
  },
  {
    "question": "181. What are the different types of Thread Priorities in Java? And what is the default priority of a thread assigned by JVM?",
    "answer": "Priorities in threads is a concept where every thread is having a priority which in layman’s language one can say every object is having priority here which is represented by numbers ranging from 1 to 10. There are different types of thread properties in Java mentioned below:\nMIN_PRIORITY\nMAX_PRIORITY\nNORM_PRIORITY \nBy default, the thread is assigned NORM_PRIORITY."
  },
  {
    "question": "182. Why Garbage Collection is necessary in Java?",
    "answer": "For Java, Garbage collection is necessary to avoid memory leaks which can cause the program to crash and become unstable. There is no way to avoid garbage collection in Java. Unlike C++, Garbage collection in Java helps programmers to focus on the development of the application instead of managing memory resources and worrying about memory leakage. Java Virtual Machine (JVM) automatically manages the memory periodically by running a garbage collector which frees up the unused memory in the application. Garbage collection makes Java memory efficient because it removes unreferenced objects from the heap memory."
  },
  {
    "question": "183. What is the drawback of Garbage Collection?",
    "answer": "Apart from many advantages, Garbage Collector has certain drawbacks mentioned below:\nThe main drawback to Garbage collection is that it can cause pauses in an application’s execution as it works to clear the memory which slows down the performance of the application. \nThe Process of Garbage collection is non-deterministic which makes it difficult to predict when garbage collection occurs which causes unpredictable behavior in applications. For Example, if we write any program then it is hard for programmers to decide if the issue is caused by garbage collection or by any other factors in the program. \nGarbage collection can also increase memory usage if the program creates and discards a lot of short-lived objects."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "184. Explain the difference between a minor, major, and full garbage collection.",
    "answer": "The Java Virtual Machine (JVM) removes objects that are no longer in use using a garbage collector which periodically checks and removes these objects. There are different types of garbage collection in the JVM, each with different characteristics and performance implications. The main types of garbage collection are:\nMinor garbage collection: Also known as young generation garbage collection, this type of garbage collection is used to collect and reclaim memory that is used by short-lived objects (objects that are quickly created and discarded). \nMajor garbage collection: Also known as old-generation garbage collection, this type of garbage collection is used to collect and reclaim memory that is used by long-lived objects (objects that survive multiple minor garbage collections and are promoted to the old generation).\nFull garbage collection: During full garbage collection, memories from all generations are collected and reclaimed, including memories of young and old. A full garbage collection normally takes longer to complete than a minor or major garbage collection which causes that app to pause temporarily."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "185. How will you identify major and minor garbage collections in Java?",
    "answer": "Major garbage collection works on the survivor space and Minor garbage collection works on the Eden space to perform a mark-and-sweep routine. And we can identify both of them based on the output where the minor collection prints “GC”, whereas the major collection prints “Full GC” for the case where the garbage collection logging is enabled with “-XX:PrintGCDetails” or “verbose:gc”."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "186. What is a memory leak, and how does it affect garbage collection?",
    "answer": "In Java Memory leaks can be caused by a variety of factors, such as not closing resources properly, holding onto object references longer than necessary, or creating too many objects unnecessarily. There are situations in which garbage collector does not collect objects because there is a reference to those objects. In these situations where the application creates lots of objects and does not use them and every object has some valid references, a Garbage collector in Java cannot destroy the objects. These useless objects which do not provide any value to the program are known as Memory leaks. Memory leaks can impact garbage collection negatively by preventing the garbage collector from reclaiming unused memory. This behavior will lead to slow performance or sometimes system failure. In a program, it is important to avoid memory leaks by managing resources and object references properly. \nExample:"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "187. Name some classes present in java.util.regex package.",
    "answer": "Regular Expressions or Regex in Java is an API used for searching and manipulating of strings in Java. It creates String patterns that can extract the data needed from the strings or can generalize a pattern.\nThere are 3 Classes present in java.util.regex mentioned below:\nPattern Class: Can define patterns\nMatcher Class: Can perform match operations on text using patterns\nPatternSyntaxException Class: Can indicate a syntax error in a regular expression pattern.\nAlso, apart from the 3 classes package consists of a single interface MatchResult Interface which can be used for representing the result of a match operation."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "188. Write a regular expression to validate a password. A password must start with an alphabet and followed by alphanumeric characters; Its length must be in between 8 to 20.",
    "answer": "regex = “^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&-+=()])(?=\\\\S+$).{8, 20}$”\n\n\n\nExplanation:\n^ used for starting character of the string.\n(?=.*[0-9]) used for a digit must occur at least once.\n(?=.*[a-z]) used for a lowercase alphabet must occur at least once.\n(?=.*[A-Z]) used for an upper case alphabet that must occur at least once in the substring.\n(?=.*[@#$%^&-+=()] used for a special character that must occur at least once.\n(?=\\\\S+$) white spaces don’t allow in the entire string.\n.{8, 20} used for at least 8 characters and at most 20 characters.\n$ used for the end of the string."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "189. What is JDBC?",
    "answer": "JDBC standard API is used to link Java applications and relational databases. It provides a collection of classes and interfaces that let programmers to use the Java programming language to communicate with the database. The classes and interface of JDBC allow the application to send requests which are made by users to the specified database. There are generally four components of JDBC by which it interacts with the database:\nJDBC API\nJDBC Driver manager\nJDBC Test Suite\nJDBC-ODBC Bridge Drivers"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "190. What is JDBC Driver?",
    "answer": "JDBC Driver is a software component that is used to enable a Java application to interact with the database. JDBC provides the implementation of the JDBC API for a specific database management system, which allows it to connect the database, execute SQL statements and retrieve data. There are four types of JDBC drivers:\nJDBC-ODBC Bridge driver\nNative-API driver\nNetwork Protocol driver\nThin driver"
  },
  {
    "question": "191. What are the steps to connect to the database in Java?",
    "answer": "There are certain steps to connect the database and Java Program as mentioned below:\nImport the Packages\nLoad the drivers using the forName() method \nRegister the drivers using DriverManager \nEstablish a connection using the Connection class object\nCreate a statement\nExecute the query\nClose the connections"
  },
  {
    "question": "192. What are the JDBC API components?",
    "answer": "JDBC API components provide various methods and interfaces for easy communication with the databases also it provides packages like java Se and java EE which provides the capability of write once run anywhere (WORA).\nSyntax:\njava.sql.*;"
  },
  {
    "question": "193. What is JDBC Connection interface?",
    "answer": "Java database connectivity interface (JDBC) is a software component that allows Java applications to interact with databases. To enhance the connection, JDBC requires drivers for each database."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "194. What does the JDBC ResultSet interface?",
    "answer": "JDBC ResultSet interface is used to store the data from the database and use it in our Java Program. We can also use ResultSet to update the data using updateXXX() methods. ResultSet object points the cursor before the first row of the result data. Using the next() method, we can iterate through the ResultSet."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "195. What is the JDBC Rowset?",
    "answer": "A JDBC RowSet provides a way to store the data in tabular form. RowSet is an interface in java that can be used within the java.sql package. The connection between the RowSet object and the data source is maintained throughout its life cycle. RowSets are classified into five categories based on implementation mentioned below:\nJdbcRowSet\nCachedRowSet\nWebRowSet\nFilteredRowSet\nJoinRowSet"
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "196. What is the role of the JDBC DriverManager class?",
    "answer": "JDBC DriverManager class acts as an interface for users and Drivers. It is used in many ways as mentioned below: \nIt is used to create a connection between a Java application and the database. \nHelps to keep track of the drivers that are available.\nIt can help to establish a connection between a database and the appropriate drivers.\nIt contains all the methods that can register and deregister the database driver classes.\nDriverManager.registerDriver() method can maintain the list of Driver classes that have registered themselves."
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "197. Differentiate between Iterable and Iterator.",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "198. Differentiate between List and Set.",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "199. Differentiate between List and Map.",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "200. Differentiate between Queue and Stack.",
    "answer": ""
  },
  {
    "question": "201. Differentiate between PriorityQueue and TreeSet.",
    "answer": ""
  },
  {
    "question": "202. Differentiate between the Singly Linked List and Doubly Linked List.",
    "answer": ""
  },
  {
    "question": "203. Differentiate between Failfast and Failsafe.",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "204. Differentiate between HashMap and TreeMap.",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "205. Differentiate between Queue and Deque.",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "206. Differentiate between HashSet and TreeSet.",
    "answer": ""
  },
  {
    "question": "Q1. What is a Java Developer’s salary in India?",
    "answer": ""
  },
  {
    "question": "Q2. What does Java Developer do?",
    "answer": ""
  },
  {
    "question": "Q3. What are the essential skills required for a Java developer?",
    "answer": ""
  },
  {
    "question": "",
    "answer": ""
  },
  {
    "question": "Q4. How can I prepare for a Java interview?",
    "answer": ""
  },
  {
    "question": "Q5. How can I stand out in a Java interview?",
    "answer": ""
  },
  {
    "question": "Please Login to comment...",
    "answer": ""
  },
  {
    "question": "Similar Reads",
    "answer": ""
  }
]